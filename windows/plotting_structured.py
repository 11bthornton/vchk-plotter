# MIT License

# Copyright (c) 2022 Ben.Thornton955@cranfield.ac.uk (ben.thornton@astrazeneca.com)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import logging
import warnings
from abc import ABC, abstractmethod

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from mne.viz import plot_connectivity_circle

from utils import warn

# DON'T LET USER KNOW ABOUT MISTAKES I'VE MADE!!!
warnings.filterwarnings("ignore")

"""Classes to facilitate consistently-themed plotting of relevant plots.

AUTHOR: Ben-Lukas Thornton.
DATE: Oct16-22.
LAST REVISED: OCT16-22.
Ben.Thornton955@cranfield.ac.uk, ben.thornton@astrazeneca.com

A class system in which each subclass (or graph plotter for a specific type
of chart) inherits style parameters and a common method to save the figure
to a given location on disk.

Typical usage example:
    x = SubstitutionPlotter(data, out_dir, type)
    x.plot().save()
"""

# Define some global parameters. Use sparingly.
plt.rcParams["figure.figsize"] = 15, 10
logging.getLogger("matplotlib.font_manager").disabled = True


class DataPlotter(ABC):
    """Models common styling parameters and saving functionality for some
    abstract graph.

    An abstract class that models a generic way of generating and saving plots
    to disk with a common styling theme. This should never be instantiated
    directly but rather implicitly through calling the constructors of its
    various concrete subclasses.

    Provides a constructor method that sets styling parameters so all plots
    generated by this program are stylistically similar. These can of course
    be overridden. Also provides a `.save()` method that saves the graph to
    disk.
    """

    @staticmethod
    def get_plotter(plot_type: str, data_frame: pd.DataFrame, out_dir: str):
        """Return correct `DataPlotter` instance.

        Instantiates the correct `DataPlotter` subclass based on the given
        type (`str`) and returns it.

        Args:
            plot_type:
                The type of subclass to return. E.g. "st".
            data_frame:
                The data the returned instance will use
                to build the plot.
            out_dir:
                Where the `DataPlotter` subclass should
                save the generated plot when the `.save()`
                method is invoked.

        Returns:
            The correct `DataPlotter` instance.
        """
        # Collect as a tuple so I can destructure this when I pass
        # it to the constructors of each subclass, rather than
        # typing out (var1, var2, var3) each time.
        args = data_frame, out_dir, plot_type

        # Match over all the possible types and return the correct instance.
        # This statement requires use of latest python version.
        match plot_type:
            case "st":
                return SubstitutionPlotter(*args)
            case "dp":
                return DepthDistributionPlotter(*args)
            case "hwe":
                return HWEPlotter(*args)
            case "idd":
                return IndelDistributionPlotter(*args)
            case "qual":
                return QualPlotter(*args)
            case "psi":
                return PerSampleIndelsPlotter(*args)
            case "af":
                return AlleleFrequencyPlotter(*args)
            case "psc":
                return PerSampleCountsPlotter(*args)
            case "tstv":
                return TsTvsPlotter(*args)
            case "sis":
                return SingletonStatsPlotter(*args)
            case "sn":
                return SummaryPlotter(*args)

    def __init__(self, data, out_dir_base, image_type, file_format="tiff",
                 dpi_quality=400) -> None:
        """Initialises an instance.

        Initialises a DataPlotter's data (pd.DataFrame), title, image quality,
        file_format and location. Also sets up some common member variables
        all of this class' subclasses can inherit to produce visually similar
        plots where this is desired.
        """
        # Set the main member variables.
        self._figure = None
        self._data = data
        self._out_dir_base = out_dir_base
        self._type = image_type
        self._file_format = file_format
        self._dpi_quality = dpi_quality

        # Common styling parameters for *all* subclasses,
        # of course these can be overriden, but is nice for all
        # generated plots to have the same theme for them and for
        # each subclass not to have to have their own hard-coded.
        self._font = {
            'family': 'serif',
            'color':  'maroon',
            'weight': 'bold',
            'size': 18,
        }

        self._title_size = 18            # Default title font size
        self._axis_label_size = 14       # Default axis_label_size
        self._default_legend_position = (1.03, 0.95)  # Position for legends
        self._title_pos = (1, 1.05)      # Default positioning for titles
        self._annotation_text_size = 12
        self._pallete = "flare"

    @abstractmethod
    def plot(self):
        """Plots the figure according to the subclass' own rules and saves
        it as a member variable: `_figure`."""

    def save(self) -> None:
        """Saves this instance's figure to disk.

        The self._figure attribute should be set before this method is invoked.
        Always invoke `.plot()` before this calling this method.

        Tries to save this plot to disk in the given output folder. This folder
        will be created if it does not exist. If it cannot be created, the program
        will error and exit.
        """
        # self._figure will be None if the plotter subclass did not finish its
        # execution (construction of the graph).
        if self._figure is not None:
            fig = self._figure.get_figure()
            fig.savefig(
                f"{self._out_dir_base}/{self._type}/{self._type}.{self._file_format}", dpi=self._dpi_quality)
        else:
            warn(True,
                 f"Could not generate {self._type} plot. Bad data? Please check input")


class SubstitutionPlotter(DataPlotter):
    """Produces a plot to show frequency of substitution types."""

    def plot(self):
        """Returns a bipartite chord plot where the strength of the line
        (read from left to right) represents the frequency of that type of 
        substitution.

        Returns
            `self`:
                For method chaining.
        """

        # Reindex the data to help with extracting the relevant data.
        self._data = self._data.set_index("type")

        a_col = {"A": 0, "C": 0, "G": 0, "T": 0}  # Transitions from A to...
        c_col = {"A": 0, "C": 0, "G": 0, "T": 0}  # Transitions from C to...
        g_col = {"A": 0, "C": 0, "G": 0, "T": 0}  # Transitions from G to...
        t_col = {"A": 0, "C": 0, "G": 0, "T": 0}  # Transitions from T to...
        matrix = {"A": a_col, "C": c_col, "G": g_col, "T": t_col}

        # Split the key so we get: "A>T" becomes ["A", "T"]
        for _type in self._data.index:
            split = _type.split(">")

            # Now place the count value in the appropriate cell in `matrix`.
            matrix[split[0]][split[1]] = self._data["count"][_type]

        # Convert this from a dict to a 2d matrix.
        matrix_data = [list(m.values()) for m in matrix.values()]

        # Hacky (not so nice) way of changing `matrix_data` into the format
        # required for the chord plot to work. NaNs are required so 0-valued
        # edges are *not* drawn on the chart.
        data = np.ones((8, 8), np.float64)
        data[:, :] = np.nan

        # From A to...
        data[5, 0] = matrix_data[0][2]
        data[6, 0] = matrix_data[0][1]
        data[7, 0] = matrix_data[0][3]

        # From C to...
        data[4, 2] = matrix_data[1][0]
        data[5, 2] = matrix_data[1][1]
        data[7, 2] = matrix_data[1][3]

        # From G to...
        data[4, 1] = matrix_data[2][0]
        data[6, 1] = matrix_data[2][2]
        data[7, 1] = matrix_data[2][3]

        # From T to...
        data[4, 3] = matrix_data[3][0]
        data[5, 3] = matrix_data[3][2]
        data[6, 3] = matrix_data[3][1]

        # Now produce the bipartite graph.
        names = ["Adenine", "Guanine", "Cytosine", "Thymine"] * 2

        # Next 6 lines adapted from MNE tutorial.
        # Used for separating out the two sets on the bipartite.
        # https://www.python-graph-gallery.com/406-chord-diagram_mne
        start, end = 45, 135
        first = (np.linspace(start, end, len(names) // 2) +
                 90).astype(int)[::+1] % 360
        second = (np.linspace(start, end, len(names) // 2) -
                  90).astype(int)[::-1] % 360
        node_angles = np.array(list(first) + list(second))

        # Produce the plot.
        fig, _ = plot_connectivity_circle(
            data,
            names,
            textcolor="black",
            # The stronger the shade of Red - the more frequent the
            # substitution type.
            colormap="Reds",
            facecolor="White",
            node_angles=node_angles,
            # Group the purine / pyrmidine pairs.
            node_colors=["Orange", "Orange", "Purple", "Purple"] * 2,
            linewidth=4,
            title="""Chord Plot to Show Frequency of Nucleobase\nSubstitution 
                Types. Read from Left to Right. \n\n Colour is Relationship 
                Strength\n(Frequency of Substitution Type)""",
            fontsize_names=12,
            node_edgecolor="White",
            show=False
        )

        self._figure = fig
        return self


class DepthDistributionPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the DP section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a simple shared x-axis line plot with two lines on two scales.
        One shows the fraction of genotypes and the other its cumulative sum.

        Plots only the first 100 bins.

        Returns
            `self`:
                For method chaining.
        """

        # Use a seaborn theme, just for this plot.
        # Closes the resources after execution
        # so other plots are not affected.
        with sns.axes_style("white"):
            figure, axis = plt.subplots()

            # Clean data into form that is workable.
            num_to_take = 100
            cum_sum = self._data["fraction of genotypes (%)"].cumsum()[
                :num_to_take]
            numbers = self._data["fraction of genotypes (%)"][:num_to_take]

            # Plot the data using defined axis instance.
            sns.lineplot(ax=axis, y=numbers, x=np.arange(num_to_take),
                         markers=True, palette=self._pallete)

            # Set title and labels for first axis.
            axis.set_title("Depth Distribution Plot",
                           y=self._title_pos[1], fontdict=self._font)
            axis.set_ylabel("Fraction of Genotypes (%)",
                            fontdict=self._font, color="blue")
            axis.set_xlabel("Bin", fontdict=self._font)

            # Plot second data set.
            second_axis = axis.twinx()
            sns.lineplot(ax=second_axis,
                         y=cum_sum, x=np.arange(num_to_take), color="orange", markers=True)
            second_axis.set_ylabel("Cumulative Proportion of Genotypes (%)",
                                   fontdict=self._font, color="orange")

            # Remove spines for aesthetic reasons.
            sns.despine()

        self._figure = figure
        return self


class HWEPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the HWE section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a simple shared x-axis line plot with two lines on two
        scales. 

        One shows the Hardy-Weinberg equilibrium and the other the 
        median with shaded percentile bands.

        Returns
            `self`:
                For method chaining.
        """

        with sns.axes_style("white"):
            figure, axis = plt.subplots()

            # Calculcate the HWE curve.
            y1 = np.array(self._data["1st alt allele frequency"])
            y2 = 1 - y1
            hwe = 2 * y1 * y2

            # Plot the HWE curve and set the title. axis.plot()
            # returns a tuple, hence comma...
            hwe, = axis.plot(y1, hwe, linestyle="dashed")
            axis.set_title("Number of Hets by Allele Frequency",
                           fontdict=self._font)

            # Plot the median line...
            median, = axis.plot(
                self._data["1st alt allele frequency"],
                self._data["median"], color="orange"
            )

            # Shade the 25th - 75th percentile around the median.
            # Alpha = 0.3.
            percentiles = axis.fill_between(
                self._data["1st alt allele frequency"],
                self._data["25th percentile"],
                self._data["75th percentile"],
                alpha=0.3
            )

            # Provide a legend and axis labels.
            axis.legend(
                loc="upper right",
                labels=["HWE", "Median", "25-75th Percentile"],
                handles=[hwe, median, percentiles]
            )
            axis.set_xlabel("Allele Frequency", fontdict=self._font)
            axis.set_ylabel("Fraction of Hets", fontdict=self._font)

            # matplotlib version of sns.despine() for aesthetic reasons.
            axis.spines['right'].set_visible(False)
            axis.spines['top'].set_visible(False)

            self._figure = figure
            return self


class IndelDistributionPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the IDD section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a histogram-esque chart showing the distribution of
        Indel length frequencies.

        NOTE: Implemented as a bar-chart for ergonomic reasons.

        Returns
            `self`:
                For method chaining.
        """

        figure, axis = plt.subplots()

        # Plot the bar chart, aligning the bars centrally to give the
        # appearance of a histogram.
        axis.bar(self._data["length (deletions negative)"],
                 self._data["count"], align="center", width=1.0, alpha=0.6)

        # Set title and axis labels using common font-styling parameters.
        axis.set_xlabel("Length. Deletions Indicated as Negative",
                        fontdict=self._font)
        axis.set_ylabel("Frequency", fontdict=self._font)
        axis.set_title("InDel Depth Frequency Chart", fontdict=self._font)

        # Remove spines for aesthetic reasons.
        axis.spines['right'].set_visible(False)
        axis.spines['top'].set_visible(False)

        self._figure = figure
        return self


class QualPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the QUAL section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a scatter plot on a log scale showing
        (log of) number of transitions vs (log of) number
        of transversions with each data point coloured
        according to its quality.

        Returns
            `self`:
                For method chaining.
        """

        with sns.axes_style("whitegrid"):
            figure, axis = plt.subplots()

            # Plot the two, and colour the scatter dots in proportion
            # to each data point's quality. Stronger shades of
            # purple are higher quality. Weak shades of orange
            # are low quality.
            scatter = sns.scatterplot(
                ax=axis,
                data=self._data,
                x="number of transitions (1st alt)",
                y="number of transversions (1st alt)",
                hue="quality"
            )

            # Plot it on a log scale to scale it down.
            scatter.set(xscale="log", yscale="log")

            # Move legend outside of the bounds of the plot.
            scatter.legend(title="Quality Score", bbox_to_anchor=(1.016, 1))

            # Set titles and axes labels.
            axis.set_xlabel("Number of Transitions (log)",
                            fontdict=self._font)
            axis.set_ylabel("Number of Transversions (log)",
                            fontdict=self._font)

            # Move title upwards slightly...
            axis.set_title(
                "Log Transitions x Log Transversions\nMarked with Quality",
                fontdict=self._font, y=1.04
            )

            self._figure = figure
            return self


class SingletonStatsPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the SiS section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a simple bar chart with count on the y axis and each
        bar representing a statistic found in this section's data table
        / frame. 

        Returns
            `self`:
                For method chaining.
        """

        # Use a different background here. Got bored.
        with sns.axes_style("darkgrid"):
            figure, axis = plt.subplots()

            # Filter out only the columns from the DataFrame that are needed
            # for this plot.
            x_labels = list(self._data.columns[2:])
            x_labels = [
                x for x in x_labels
                if not x in ["repeat-consistent", "repeat-inconsistent"]
            ]
            y_values = [
                self._data.loc[self._data.index[0]][name] for name in x_labels
            ]

            # Use for positioning the bars. Rename them later...
            x_ticks = np.arange(len(x_labels))
            sns.barplot(
                ax=axis,
                x=x_ticks,
                y=y_values,
                width=0.4,
                alpha=0.7,
                palette=self._pallete
            )

            # Set the figure title, axis labels and the names for the bars.
            axis.set_title("Singleton Stats", fontdict=self._font)
            axis.set_xticks(x_ticks, x_labels)
            axis.set_ylabel("Value", fontdict=self._font)
            axis.set_xlabel("Statistic", fontdict=self._font)

            self._figure = figure
            return self


class AlleleFrequencyPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the AF section
    of the input .vchk file.
    """

    def plot(self):
        """Returns a 3D Scatter Plot of the frequency of:

        - Transitions
        - Transversions
        - Indels

        Returns
            `self`:
                For method chaining.
        """

        with sns.axes_style("whitegrid"):
            figure = plt.figure()

            # Use a 3d projection here.
            axis = figure.add_subplot(projection="3d")

            # Plot x, y, and z on to the axis.
            axis.scatter(self._data["number of transitions"],
                         self._data["number of transversions"],
                         self._data["number of indels"])

            # Format and style the plot.
            axis.set_title("Transitions vs Indels vs Transversions",
                           fontdict=self._font)
            axis.set_xlabel("Num. Transitions", fontdict=self._font)
            axis.set_ylabel("Num. Transversions", fontdict=self._font)
            axis.set_zlabel("Num. Indels", fontdict=self._font)

        self._figure = figure
        return self


class TsTvsPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the TsVS section
    of the input .vchk file.
    """

    def plot(self):
        """Simple bar chart for a simple table.

        One bar shows the number of transitions.
        The other shows the number of transversions.

        Returns
            `self`:
                For method chaining.
        """

        with sns.axes_style("whitegrid"):

            figure, axis = plt.subplots()

            # Grab the columns.
            # We're only expecting one row due to
            # nature of the table./
            first_column = self._data["ts"][0]
            second_column = self._data["tv"][0]

            # Plot the bar chart.
            sns.barplot(
                ax=axis,
                x=["Transitions", "Transversions"],
                y=[first_column, second_column],
                width=0.3,
                palette=self._pallete
            )

            # Now set the titles and axis labels.
            # Professional.
            axis.set_xlabel("Metric (Transitions / Transversions)",
                            fontdict=self._font)
            axis.set_ylabel("Count", fontdict=self._font)
            axis.set_title("Transitions / Transversions Counts",
                           fontdict=self._font)

            self._figure = figure
            return self


class PerSampleCountsPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the PSC section
    of the input .vchk file.
    """

    def plot(self):
        """Interesting grouped horizontal bar chart that shows
        the value of each statistic (frequency/count) per sample.
        The same statistic across each sample are coloured the same.

        Bars are additionally annotated with their value for ease-of-
        reading.

        Returns
            `self`:
                For method chaining.
        """

        # Back to black.
        with sns.axes_style("darkgrid"):
            figure, axis = plt.subplots()

            # Use Pands drop and melt methods to transform data into format
            # needed for this type of plot.
            formatted = self._data.drop("id", axis=1)
            formatted = formatted.drop("average depth", axis=1)

            formatted = formatted \
                .melt(id_vars="sample") \
                .rename(columns=str.title)

            # Use the formatted data to prduce the graph.
            sns.barplot(
                ax=axis,
                x="Value",
                y="Sample",
                hue="Variable",
                data=formatted,
                palette=self._pallete,
                orient="h"      # So bars stem from the y-axis.
            )

            # Format titles, labels and gridlines.
            axis.grid(visible=True, axis="y", alpha=0.3)
            axis.set_title(
                "Counts per Stat per Sample",
                fontdict=self._font,
                y=self._title_pos[1],
                fontsize=30
            )
            axis.set_xlabel("Value (Count)", fontdict=self._font)
            axis.set_ylabel("Sample", fontdict=self._font)

            # Despine the graph for aesthetic purposes.
            sns.despine(figure)

            # Annotate all the bars with their values,
            # formatted appropriately.
            for container in axis.containers:
                axis.bar_label(container, fmt="%.1d")

            # Move the legend and tighten the layout.
            sns.move_legend(
                axis,
                "upper left",
                bbox_to_anchor=self._default_legend_position
            )
            figure.tight_layout()

            self._figure = figure
            return self


class PerSampleIndelsPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the PSI section
    of the input .vchk file.
    """

    def plot(self):
        """Plots two bar charts on one figure sharing a common
        x-axis so that sample names aren't unnecessarily
        repeated.

        Top bar chart shows nhets and bottom displays
        naa.

        Returns
            `self`:
                For method chaining.
        """

        with sns.axes_style("whitegrid"):
            figure, (axis1, axis2) = plt.subplots(2, sharex=True)

            # Set the title for the overall figure rather than
            # just the axis this time
            figure.suptitle("Plot to show Num Hets by Sample",
                            fontdict=self._font)

            # Plot the two bar charts onto the correct respective axes.
            width = 0.3
            sns.barplot(
                ax=axis1,
                data=self._data,
                x="sample",
                y="nhets",
                width=width,
                palette=self._pallete
            )

            sns.barplot(
                ax=axis2,
                data=self._data,
                x="sample",
                y="naa",
                width=width,
                palette=self._pallete
            )

            # Set the x-labels. Top X label should be nothing because
            # they're displayed as the X-labels for the bottom
            # axis and don't need to be repeated.
            axis1.set_xlabel("")
            axis2.set_xlabel("Sample", fontdict=self._font)

            # Set the y-labels.
            axis1.set_ylabel("Num Hets", fontdict=self._font)
            axis2.set_ylabel("Num AA", self._font)

            self._figure = figure
            return self


class SummaryPlotter(DataPlotter):
    """Implements the methods required to produce a plot for the Summary 
    Numbers section of the input .vchk file.
    """

    def plot(self):
        """Plot Simple Bar Chart.

        Returns
            `self`:
                For method chaining.
        """
        figure, axis = plt.subplots()

        with sns.axes_style("white"):

            num_samples = self._data["value"][0]
            multi_allelic_snp = self._data["value"][8]

            # Drop the num samples and last value.
            # Include them in the title instead because
            # their relative scale to the other numbers
            # will distort the bar chart :(
            self._data.drop([0, 8], inplace=True)
            bar = sns.barplot(ax=axis, data=self._data, x="key", y="value",
                              palette=self._pallete)

            labels = list(self._data["key"])
            cleaned = [label.split("number of ")[1].strip().replace(
                ":", "") for label in labels]

            bar.set_xticklabels(cleaned)

            bar.set_xlabel("Key", fontdict=self._font)
            bar.set_ylabel("Value (Count)", fontdict=self._font)
            bar.bar_label(bar.containers[0])

            sns.despine()

            axis.set_title(
                f"Summary Numbers.\nNum Samples = {num_samples}\nMulti-Allelic SNP = {multi_allelic_snp}", fontdict=self._font)

        self._figure = figure
        return self
